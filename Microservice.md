
# MicroService
마이크로서비스 아키텍처 패턴은 모놀리틱 아키텍처로 구성된 하나의 큰 서비스를 각각의 독립적인 역할을 수행하는 
작은 단위의 서비스로 분리하여 설계하는 패턴이다. 여기에서 말하는 독립적인 역할은 주로 
- 사용자 관리
- 주문 관리
- 결제 관리
- 알림 관리
 
와 같은 기능적인 요소들을 의미한다.
각각의 마이크로서비스는 크기만 작을 뿐, 하나의 모놀리틱 아키텍처와 유사한 구조를 가진다.
다만, 하나의 서비스에서 처리해야 하는 기능과 규모가 작기 때문에 마이크로서비스라고 부른다.

## Microservice VS Monolithic

![MicroService Architecthre example](http://4.bp.blogspot.com/-i-Xp5DRyvMc/VIF98b0JvBI/AAAAAAAAAZY/VBhHnw6tZwQ/s1600/Monoliths%2Band%2BMicroservices.png)

Microservice는 Monolithic 방식과 비교가 된다. Monolithic Application은 덩어리 단위로 개발된다. 일반적으로 기업 애플리케이션들은
세 주요부분으로 구성된다. 클라이언트 측 사용자 로직(사용자의 브라우저에서 동작하는 HTML페이지, 자바스크립트), 도메인 로직 (일반적인 RDBMS),서버 측 애플리케이션 로직이다. 애플리케이션은 HTTP 요청을 수락하고, 도메인 로직으로 데이터 베이스로 부터 데이터를 갱신하거나 추출 해, 브라우저에게 전송할 HTML 뷰에 덧붙여 클라이언트에 응답을 반환한다.이런 경우에 Monolithic 방식을 갖는다. 즉, 한 덩어리 안에서 로직을 실행한다.  변경이 필요한 경우, 이런 애플리케이션은 이를 반영한 전체 애플리케이션을 새롭게 빌드해 배포해야한다.

이 때문에 Monolithic Application 은 작은 부분을 변경하더라도, 전체 애플리케이션을 다시 빌드하고 배포해야 한다. 결과적으로 시간이 지나면서 모듈 구조는 훼손되고, 여러 모듈 중에서 한 모듈만 변경한는 것도 쉽지 않게 된다. 일부만 확장하려고 해도, 전체 애플리케이션을 확장해야 하므로, 많은 자원을 사용해야 한다. 

이에 반해 Microservice Architecture 는 작은 서비스(service) 들의 집합으로써, Application(monolithic application)을 개발하는 방법이다. 서비스들은 각각이 프로세스고, 서비스로써 HTTP, JMX,AMQP,STOMP, REST API 같은 가벼운 통신 메커니즘을 사용한다. 서비스들은 비즈니스를 구현하고, 각각은 완전히 자동화된 방법으로 독립적으로 배포될 수 있다. 서비스들을 위해 최소한의 중앙관리를 사용한다. 서비스들은 다른 프로그래밍 언어로 개발될 수 있고, 다른 데이터 저장 기술을 사용할 수 있다.


## Microservice Architecture

![MicroService Architecthre example](http://www.popit.kr/wp-content/uploads/2016/08/2-600x423.png)

마이크로서비스 아키텍처의 개략적인 모습을 예시로 나타낸 그림이다.
이 예시는 총 4개의 마이크로 서비스로 구성되어 있으며, 사용자 서비스는 REST API 를 이용해서 주문 서비스를 활용,
API Gateway 를 통해 Web UI 나 모바일 클라이언트에 데이터를 제공한다.
또한, 사용자에게 알림이 필요한 경우 실제 알림 서비스의 처리 과정을 신경 쓸 필요 없이 알림 서비스를 이용하여
원하는 요청을 호출할 수 있다.

여기서 주목할 점은 User 데이터베이스와 Order 데이터베이스가 따로 존재한다는 것인데 마이크로서비스 아키텍처의 근본적인 장점을
최대한 활용하기 위해서는 이렇게 서비스별로 별도의 데이터베이스를 사용하는 것이 필요하다.
이렇게 개별 서비스들이 데이터베이스를 공유하지 않음으로써 각각의 서비스 특성에 맞게 데이터베이스의 종류와 설계를 결정할 수 있다.

## Microservice Architecture의 장점
마이크로서비스 아키텍처는 서비스 규모가 커지고 복잡도가 증가할 수록 장점을 갖는다.
우선 개별 서비스간의 의존성을 최소화함으로써 업데이트 및 테스트가 용이하며 서비스별로 빠르게 배포가 가능하다.
그렇기 때문에 필요에 따라 자주 배포하는 것이 가능하며, 비용적인 부분에서도 부하가 집중되는 특정 서비스를 위해 
전체 애플리케이션을 스케일 아웃할 필요가 없기 때문에 불필요한 자원의 낭비를 줄일 수 있다. 
즉, 서비스의 특성에 맞게 자원을 할당하여 스케일 아웃을 할 수 있기 때문에 효율적인 자원 사용이 가능하다.

## Microesrvice Architecture의 단점
마이크로 서비스의 대표적인 단점으로는 모놀리틱 아키텍처에 비해 서비스 간의 통신에 대한 처리가 추가적으로 필요하다는 점이다.
단순히 개발해야 하는 코드의 양이 늘어날 뿐만 아니라, 사용자의 요청을 처리하기 위한 응답속도의 증가에도 영향을 미친다.
또한 분산된 데이터베이스는 트랜잭션 관리가 용이하지 않기 때문에 데이터의 정합성을 맞추기 위한 노력도 필요하다.
* 종류까지 서로 다른 데이터베이스 내 데이터의 정합성을 유지하기 위한 트랜잭션 처리는 대부분의 데이터베이스가 자체적으로 
 지원하지 않기 때문에 애플리케이션의 개발과정에서 항상 고려해야 한다는 어려움이 있다.


## API Gateway

![Processing requests in the micro-service architecture](http://www.popit.kr/wp-content/uploads/2016/08/5.png)

### Microservice Architecture 에서의 요청처리
여기서 각각의 마이크로 서비스들은 각각이 담당한 내용에 대한 응답을 클라이언트에 보내주게 된다. 하지만 이를 실제로 구현하기 위해서는 메인 페이지를 화면에 표시하기 위해 관련된 많은 각각의 서비스들에 요청을 보내야 하는데, 그러기 위해서는 클라이언트가 각각의 마이크로서비스들의 호스트명과 end_point 를 알고 있어야 된다. 클라이언트는 서버에 요청을 보내고 응답을 받기 위해 네트워크 지연속도가 필요한데 요청의 회수(서비스 개수)가 증가할수록 응답속도가 늦어진다는 문제점이 생긴다.
또한 이와 같은 방식의 요청처리를 클라이언트에서 구현하려면 아주 복잡하게 된다는 점이다. 이후 마이크로서비스들이 분리되거나 합치는 상황이 발생할 경우 코드를 수정하는 것 또한 어려워 질 수 있다.

![Request handling in micro-service architecture using API Gateway](http://www.popit.kr/wp-content/uploads/2016/08/6-600x410.png)

### API Gateway 를 이용한 Microservice Architecture 에서의 요청처리
하지만 API Gateway 를 이용하면 서비스로 전달되는 모든 API 요청을 기반으로 필요한 마이크로서비스에 개별적인 요청을 보낼 수 있게 된다.
이렇게 각각의 마이크로서비스로부터 받은 응답들을 API Gateway 에서 다시 취합하여 클라이언트로 전달하는 역할을 수행하며
특정 서비스의 변경사항이나 마이크로서비스의 분리/통합이 생기더라도 클라이언트에서는 이를 인지할 필요 없이 API Gateway 에서 내부
변경사항만으로 처리할 수 있게 된다.

### 단점
구현하고 관리해야 하는 요소가 하나 더 증가한다는 점과 성능상의 병목지점이 될 수 있다는 것이다.
API Gateway 는 모든 요청을 수용하는 창구 역할이기 때문에 병목현상이 발생하면 서비스 전체의 품질에 큰 영향을 미칠 수 있다.
그래서 항상 확장성과 성능을 고려해야 하며, 비동기적이고 non-blocking I/O 처리가 가능하도록 구현하는 것이 적은 비용으로 최대의 성능을 발휘할 수 있는 관건이 될 수 있다.

### API Gateway 구현 시 고려해야 할 점들
- ###### Reactive 방식
API Gateway 는 동시에 여러 개의 요청을 각각의 마이크로서비스에 전달하는 것이 가능하다. 하지만 항상 모든 요청이 병렬로 처리되는 것이 아니라 개별 마이크로서비스로 보내는 요청의 선후관계가 존재할 수 있다. 이러한 경우 콜백함수를 이용하게 되는데 이러한 방식의 애플리케이션 코드들이 흔히 말하는 콜백지옥을 경험하게 함으로써 유지보수와 코드의 가독성을 악화시키는 원인이 된다. 
이러한 문제점 때문에 동일한 처리를 수행하는 코드를 좀 더 직관적이고 서술적으로 표현하는 reactive 접근방식으로 API Gateway 를 구현하게 되면
비동기 처리의 성능적인 이점과 좀 더 직관적이고 관리하기 쉬운 코드를 작성할 수 있다.

- ###### 예외처리
마이크로서비스 아키텍처에서는 모놀리틱 아키텍처에 비해 분산된 서버의 상태와 여러가지 변수들로 인해 일부 서비스에 장애가 발생하거나 응답속도가 지연될 가능성이 높다. 이렇게 특정서비스에 문제가 발생했을 때 API Gateway 는 서비스 장애의 종류에 따라 적절한 처리가 가능하도록 설계/구현 되어야 한다.

- ###### 재활용
API gateway 는 모든 요청이 몰리는 지점이기 때문에 동일한 요청에 대해 중복적으로 마이크로서비스에 요청을 보내는 것 보다 기존의 결과를 캐싱하여 재활용 할 수 있도록 설계하는 것이 중요하다.
## 오픈소스 지원도구 - NetFlix
마이크로서비스를 지원하기 위해 NetFlix 에서 개발한 오픈소스 S/W 가 있다. 마이크로서비스 아키텍처에서는 기존과는 달리 
많은 서비스들이 수시로 업데이트되고 운영되기 때문에, 기존의 모니터링이나 자동화 툴로는 해결되기 어려운 부분이 많았다. 
이것을 해결하고자 NetFlix 에서 자체 개발한 많은 툴들을 오픈소스로 내놓게 되었다.
주로 많이 활용되고 있는 NetFlix 의 주요 오픈소스 S/W 로는

- Asgard(애플리케이션 배포 자동화 및 클라우드 관리 툴)
- Hystrix(서비스 가동성, 오류 모니터링 및 관리)
- Eureka(서비스 등록 및 검색)
- Ribbon(Client-side 로드밸런싱)

등이 있다.

Spring 재단에서도 NetFlix 를 쉽게 활용할 수 있도록 하는 Spring Cloud Netflix 프로젝트를 운영하고 있다.
이를 활용하면 한 줄의 코드 추가로 Netflix 오픈소스 S/W 를 Spring Framework 에 적용할 수 있다.
이 외, Gilt 나 Capital One 등에서도 오픈소스 툴들을 내놓고 있는 상황이다.

Ref : http://www.popit.kr/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AD%A3%EC%9D%B4-%EC%A4%91%ED%97%8C%EB%94%94/

